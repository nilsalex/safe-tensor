{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE EmptyCase #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE KindSignatures #-}
-- {-# LANGUAGE NoStarIsType #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE StandaloneDeriving #-}

module Lib where

import Data.Singletons.Prelude
import Data.Singletons.Prelude.List
import Data.Singletons.Prelude.List.NonEmpty hiding (sSort, SortSym0)
import Data.Singletons.TH

import Data.List (sort)
import Data.List.NonEmpty (NonEmpty((:|)))

$(singletons [d|
  data Nat where
      Zero :: Nat
      Succ :: Nat -> Nat

  data VSpace = VSpace { vDim :: Nat } deriving (Show, Ord, Eq)

  data Pos = Cov | Con deriving (Show, Ord, Eq)

  type IList = [(VSpace, Pos)]

  n0 :: Nat
  n0 = Zero

  n1 :: Nat
  n1 = Succ n0

  n2 :: Nat
  n2 = Succ n1

  n3 :: Nat
  n3 = Succ n2

  n4 :: Nat
  n4 = Succ n3

  deriving instance Show Nat
  deriving instance Eq Nat
  deriving instance Ord Nat
  
  nonZero :: Nat -> Bool
  nonZero Zero     = False
  nonZero (Succ n) = True
  |])

toInt :: Nat -> Int
toInt Zero = 0
toInt (Succ n) = toInt n + 1

data Tensor :: IList -> * -> * where
    ZeroTensor :: forall (l :: IList) v.Tensor l v
    Scalar :: forall (l :: IList) v.l ~ '[] => v -> Tensor l v
    Tensor :: forall (l :: IList)
                     (l' :: IList)
                     s
                     v.
              (l ~ (s : l')) =>
              [(Int, Tensor l' v)] -> Tensor l v

deriving instance Show v => Show (Tensor k v)

unionWith :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [(Int, a)] -> [(Int, b)] -> [(Int, c)]
unionWith _ _ f [] ys = fmap (fmap f) ys
unionWith _ f _ xs [] = fmap (fmap f) xs
unionWith f g h xs@((ix,vx):xs') ys@((iy,vy):ys')
    | ix == iy = (ix, f vx vy) : unionWith f g h xs' ys'
    | ix <  iy = (ix, g vx) : unionWith f g h xs' ys
    | ix >  iy = (iy, h vy) : unionWith f g h xs ys'

addLists :: (Num a, Eq a) => [(Int, a)] -> [(Int, a)] -> [(Int, a)]
addLists [] ys = ys
addLists xs [] = xs
addLists xs@((ix,vx):xs') ys@((iy,vy):ys')
    | ix == iy = let vz = vx + vy
                     zs = addLists xs' ys' in
                 if vz == 0
                 then zs
                 else (ix, vz) : zs
    | ix < iy = (ix, vx) : addLists xs' ys
    | ix > iy = (iy, vy) : addLists xs ys'

addTens' :: forall (l :: IList) (l' :: IList) v.
            ((l ~ l'), Num v) =>
            Tensor l v -> Tensor l' v -> Tensor l v
addTens' ZeroTensor t = t
addTens' t ZeroTensor = t
addTens' (Scalar s) (Scalar s')   = Scalar (s + s')
addTens' (Tensor xs) (Tensor xs') = Tensor xs''
    where
       xs'' = unionWith addTens' id id xs xs' 

negateTens' :: forall (l :: IList) v. Num v =>
               Tensor l v -> Tensor l v
negateTens' ZeroTensor = ZeroTensor
negateTens' (Scalar s) = Scalar $ negate s
negateTens' (Tensor x) = Tensor $ fmap (fmap negateTens') x

subTens' :: forall (l :: IList) (l' :: IList) v.
            ((l ~ l'), Num v) =>
            Tensor l v -> Tensor l' v -> Tensor l v
subTens' t1 t2 = t1 `addTens'` (negateTens' t2)

{-
prodTens' :: forall (l :: SlotLists) (l' :: SlotLists) (l'' :: SlotLists) v.
             (Num v, l'' ~ AddSLLists l l', SaneLabels l'' ~ 'True) =>
             Tensor l v -> Tensor l' v -> Tensor l'' v
prodTens' _ _ = ZeroTensor

toListTens :: forall (l :: SlotLists) v.
              (SaneLabels l ~ 'True, SingI l) =>
              Tensor l v -> [(([(Slot, Int)], [(Slot, Int)]), v)]
toListTens ZeroTensor = []
toListTens (Scalar s) = [(([], []), s)]
toListTens (Tensor ms) = case sFst (sSlHeadTail (sing :: Sing l)) of
    slot -> [(([(fromSing slot, 0)], []), undefined)]
-}

delta :: Num v => Tensor '[ '( 'VSpace N4, 'Cov), '( 'VSpace N4, 'Con)] v
delta = let x = 4
        in Tensor (f x)
  where
    f x = map (\i -> (i, Tensor [(i, Scalar 1)])) [0..x - 1]

eta :: Num v => Tensor '[ '( 'VSpace N4, 'Cov), '( 'VSpace N4, 'Cov)] v
eta = let x = 4
      in Tensor (f x)
  where
    f x = map (\i -> (i, Tensor [(i, Scalar (if i == 0 then -1 else 1))])) [0..x - 1]

someFunc :: IO ()
someFunc = putStrLn "someFunc"
